---
title: "Análisis municipios"
output: html_document
date: "2024-04-15"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Paquetes

```{r}
library(tidyverse)
library(readxl)
library(haven)
library(mice)
library(factoextra)
library(ggpubr)
library(car)
library(lmtest)


```


## Importar base de datos

```{r}

municipios <- read_xlsx("municipios.xlsx")

propiedad <- read_xlsx("propiedad.xlsx")

```

## Descriptivo de lss variables de municipios
### IPV
Panorama general: en los ultimos años ha aumentado tal, viviendas vacias por ejemplo, tal nivel de turisticas. Esto lleva a un regimen de tenencia que tal. Pero es asi en todos?

- IPV. El IPV es un índice que mide la evolución de precios de las viviendas partiendo de una base 100 establecida por el precio en 2015. La media del IPV General, resultado del precio de todas las viviendas en el mercado es de 125, lo que indica un aumento del precio del 25% desde 2015. 

En los boxplot observamos que el IPV General tiene varios outliers con un valor mucho más alto que la media. Vemos también  que esto se repite en los casos de IPV de vivienda de Segunda mano y de vivienda Nueva. El IPV general tiene un valor mucho más cercano al de IPV Segunda, lo que nos indica que en el mercado hay más compraventa de viviendas de segunda mano que de nueva construcción.

Las CCAA donde ha aumentado más el precio de la vivienda son Madrid, Illes Balears, Barcelona, Ceuta y Melilla.

```{r}

# IPV
mean(municipios$ipv2021General)
mean(municipios$ipv2011General)

ggplot(municipios, aes(x = 1, y = ipv2021General, fill = "ipv2021General")) +
  geom_boxplot(position = position_dodge(width = 0.8), fill = "Orange") +
  geom_boxplot(aes(x = 2, y = ipv2021Nueva, fill = "ipv2021Nueva"), position = position_dodge(width = 0.8), fill = "Blue") +
  geom_boxplot(aes(x = 3, y = ipv2021Segunda, fill = "ipv2021Segunda"), position = position_dodge(width = 0.8), fill = "Green") +
  scale_x_continuous(breaks = c(1, 2, 3), labels = c("ipv2021General", "ipv2021Nueva", "ipv2021Segunda")) +
  labs(y = "Índice de Precio de Viviendas",
       title = "Distribución del Índice de Precio de Viviendas por Tipo en 2021") +
  theme_minimal()

# top ipv 2021
municipios |> 
  distinct(CCAA, .keep_all = T) |> 
  arrange(desc(ipv2021General)) |> 
  slice(1:5)




# Edad
mean(compra21_r$VAREDAD)
round(prop.table(table(compra21_r$VAREDAD)), digits = 3)
hist(compra21_r$VAREDAD)

# Número de orden
round(prop.table(table(compra21_r$NORDEN)), digits = 3)
(table(compra21_r$NORDEN))

bxp<-ggplot(data,mapping=aes(x=Priorprograms))+geom_histogram(bins=15,fill="Orange",aes(y=..count../sum(..count..)))

ggarrange(bxp,dp,db,ds,
          ncol = 2, nrow = 2)



```

### RentaMedia2021

Renta media disponible/neta personal. El valor medio de los municipios es 21236€ anuales. Sin embargo hay mucha variación entre municipios. El municipio con más renta es Pozuelo de Alarcón con un valor de 57977€, mientras el de renta más baja es Tudela en Navarra con 13443€.

```{r}
mean(municipios$RentaMedia2021)

municipios |> 
  arrange(desc(RentaMedia2021)) |> 
  slice(1:3) |> 
  select(PROV_LITERAL, MUN_LITERAL, RentaMedia2021)

municipios |> 
  arrange(RentaMedia2021) |> 
  slice(1:3) |> 
  select(PROV_LITERAL, MUN_LITERAL, RentaMedia2021)


```

### PorcentajeJoven

La media del porcentaje de población joven en los municipios en 2021 es de 36%, mientras que en 2011 era 39%. Ha descendido la cantidad de jóvenes.

Los municipios donde hay más población joven son Vícar en Almería probablemente por la alta presencia de temporeros jóvenes, 

```{r}

mean(municipios$PorcentajeJoven2021)
mean(municipios$PorcentajeJoven2011)

municipios |> 
  arrange(desc(PorcentajeJoven2021)) |> 
  slice(1:3) |> 
  select(PROV_LITERAL, MUN_LITERAL, PorcentajeJoven2021)

municipios |> 
  arrange(PorcentajeJoven2021) |> 
  slice(1:3) |> 
  select(PROV_LITERAL, MUN_LITERAL, PorcentajeJoven2021)



```


# Descriptivo: en qué municios/provincia entonces ha aumentado la compra

No, no es en todos. En estos municipios pasa tal. Hacer análisis por provincias y revisar los casos estos donde top herencia = top diferencia. Porque por ejemplo en Jaén 2000 no era por herencia, sino por temas de cesión.

### Mapa Provincias
### En 2011

```{r, fig.height=6, fig.width=12}

library(mapSpain)
  
esp_can <- esp_get_country() 
can_prov <- esp_get_can_provinces()
can_box <- esp_get_can_box() 
munic <- esp_get_munic() 

provic <- esp_get_prov() |> 
  mutate(CPRO = cpro)

mapa <- propiedad |> 
  select(CPRO, Propiedad11Prov) |> 
  distinct(CPRO, .keep_all = TRUE)

mapa <- provic |> 
  left_join(mapa, by = "CPRO")

# Propiedad
p1 <- ggplot(esp_can) +
  geom_sf() +
  geom_sf(data = can_prov) +
  geom_sf(data = can_box) + 
  geom_sf(data = mapa, aes(fill = Propiedad11Prov), color = "black", size = 1) + 
        geom_sf_text(data = mapa, aes(label = round(Propiedad11Prov, 1)), color = "black", size = 2.5, check_overlap = TRUE, nudge_y = 0.1) +  # Agregar etiquetas
  theme_void() +  
  labs(title = "Porcentaje de propiedad por provincia 2011") +  
  theme(legend.position = c(0.18, 0.55),    
        legend.justification = "center",   
        legend.background = element_rect(fill = NULL, colour = "black"),
        legend.margin = margin(6, 6, 6, 6)) + 
  guides(fill = guide_legend(ncol = 2)) + 
  coord_sf() +
  scale_fill_viridis_c(option = "C", direction = -1)

# Herencia o donación

mapa <- propiedad |> 
  select(CPRO, Herencia11Prov) |> 
  distinct(CPRO, .keep_all = TRUE)

mapa <- provic |> 
  left_join(mapa, by = "CPRO")

p2 <- ggplot(esp_can) +
  geom_sf() +
  geom_sf(data = can_prov) +
  geom_sf(data = can_box) + 
  geom_sf(data = mapa, aes(fill = Herencia11Prov), color = "black", size = 1) + 
        geom_sf_text(data = mapa, aes(label = round(Herencia11Prov, 1)), color = "black", size = 2.5, check_overlap = TRUE, nudge_y = 0.1) +  # Agregar etiquetas
  theme_void() +  
  labs(title = "Porcentaje de herencia/donación por provincia 2011") +  
  theme(legend.position = c(0.18, 0.55),    
        legend.justification = "center",   
        legend.background = element_rect(fill = NULL, colour = "black"),
        legend.margin = margin(6, 6, 6, 6)) + 
  guides(fill = guide_legend(ncol = 2)) + 
  coord_sf() +
  scale_fill_viridis_c(option = "C", direction = -1)

# Alquiler
mapa <- propiedad |> 
  select(CPRO, Alquiler11Prov) |> 
  distinct(CPRO, .keep_all = TRUE)

mapa <- provic |> 
  left_join(mapa, by = "CPRO")

p3 <- ggplot(esp_can) +
  geom_sf() +
  geom_sf(data = can_prov) +
  geom_sf(data = can_box) + 
  geom_sf(data = mapa, aes(fill = Alquiler11Prov), color = "black", size = 1) + 
        geom_sf_text(data = mapa, aes(label = round(Alquiler11Prov, 1)), color = "black", size = 2.5, check_overlap = TRUE, nudge_y = 0.1) +  # Agregar etiquetas
  theme_void() +  
  labs(title = "Porcentaje de alquiler por provincia 2011") +  
  theme(legend.position = c(0.18, 0.55),    
        legend.justification = "center",   
        legend.background = element_rect(fill = NULL, colour = "black"),
        legend.margin = margin(6, 6, 6, 6)) + 
  guides(fill = guide_legend(ncol = 2)) + 
  coord_sf() +
  scale_fill_viridis_c(option = "C", direction = -1)

# Otro
mapa <- propiedad |> 
  select(CPRO, Otro11Prov) |> 
  distinct(CPRO, .keep_all = TRUE)

mapa <- provic |> 
  left_join(mapa, by = "CPRO")

p4 <- ggplot(esp_can) +
  geom_sf() +
  geom_sf(data = can_prov) +
  geom_sf(data = can_box) + 
  geom_sf(data = mapa, aes(fill = Otro11Prov), color = "black", size = 1) + 
        geom_sf_text(data = mapa, aes(label = round(Otro11Prov, 1)), color = "black", size = 2.5, check_overlap = TRUE, nudge_y = 0.1) +  # Agregar etiquetas
  theme_void() +  
  labs(title = "Porcentaje de otro por provincia 2011") +  
  theme(legend.position = c(0.18, 0.55),    
        legend.justification = "center",   
        legend.background = element_rect(fill = NULL, colour = "black"),
        legend.margin = margin(6, 6, 6, 6)) + 
  guides(fill = guide_legend(ncol = 2)) + 
  coord_sf() +
  scale_fill_viridis_c(option = "C", direction = -1)


ggarrange(p1, p2, p3, p4, ncol=2, nrow = 2)

```

### En 2021

```{r, fig.height=6, fig.width=12}

library(mapSpain)
  
esp_can <- esp_get_country() 
can_prov <- esp_get_can_provinces()
can_box <- esp_get_can_box() 
munic <- esp_get_munic() 
  
ccaa <- esp_get_ccaa() |> 
  mutate(codauto = codauto)

mapa <- propiedad |> 
  select(CPRO, Propiedad21Prov) |> 
  distinct(CPRO, .keep_all = TRUE)

mapa <- provic |> 
  left_join(mapa, by = "CPRO")

# Propiedad
p1 <- ggplot(esp_can) +
  geom_sf() +
  geom_sf(data = can_prov) +
  geom_sf(data = can_box) + 
  geom_sf(data = mapa, aes(fill = Propiedad21Prov), color = "black", size = 1) + 
        geom_sf_text(data = mapa, aes(label = round(Propiedad21Prov, 1)), color = "black", size = 2.5, check_overlap = TRUE, nudge_y = 0.1) +  # Agregar etiquetas
  theme_void() +  
  labs(title = "Porcentaje de propiedad por provincia 2021") +  
  theme(legend.position = c(0.18, 0.55),    
        legend.justification = "center",   
        legend.background = element_rect(fill = NULL, colour = "black"),
        legend.margin = margin(6, 6, 6, 6)) + 
  guides(fill = guide_legend(ncol = 2)) + 
  coord_sf() +
  scale_fill_viridis_c(option = "C", direction = -1)

# Alquiler
mapa <- propiedad |> 
  select(CPRO, Alquiler21Prov) |> 
  distinct(CPRO, .keep_all = TRUE)

mapa <- provic |> 
  left_join(mapa, by = "CPRO")

p2 <- ggplot(esp_can) +
  geom_sf() +
  geom_sf(data = can_prov) +
  geom_sf(data = can_box) + 
  geom_sf(data = mapa, aes(fill = Alquiler21Prov), color = "black", size = 1) + 
        geom_sf_text(data = mapa, aes(label = round(Alquiler21Prov, 1)), color = "black", size = 2.5, check_overlap = TRUE, nudge_y = 0.1) +  # Agregar etiquetas
  theme_void() +  
  labs(title = "Porcentaje de alquiler por provincia 2021") +  
  theme(legend.position = c(0.18, 0.55),    
        legend.justification = "center",   
        legend.background = element_rect(fill = NULL, colour = "black"),
        legend.margin = margin(6, 6, 6, 6)) + 
  guides(fill = guide_legend(ncol = 2)) + 
  coord_sf() +
  scale_fill_viridis_c(option = "C", direction = -1)

# Otro
mapa <- propiedad |> 
  select(CPRO, Otro21Prov) |> 
  distinct(CPRO, .keep_all = TRUE)

mapa <- provic |> 
  left_join(mapa, by = "CPRO")

p3 <- ggplot(esp_can) +
  geom_sf() +
  geom_sf(data = can_prov) +
  geom_sf(data = can_box) + 
  geom_sf(data = mapa, aes(fill = Otro21Prov), color = "black", size = 1) + 
        geom_sf_text(data = mapa, aes(label = round(Otro21Prov, 1)), color = "black", size = 2.5, check_overlap = TRUE, nudge_y = 0.1) +  # Agregar etiquetas
  theme_void() +  
  labs(title = "Porcentaje de otro por provincia 2021") +  
  theme(legend.position = c(0.18, 0.55),    
        legend.justification = "center",   
        legend.background = element_rect(fill = NULL, colour = "black"),
        legend.margin = margin(6, 6, 6, 6)) + 
  guides(fill = guide_legend(ncol = 2)) + 
  coord_sf() +
  scale_fill_viridis_c(option = "C", direction = -1)


ggarrange(p1, p2, p3, ncol=2, nrow = 2)


```


# Regímenes de tenencia
### 2011

### Por municipios

```{r}
# Propiedad

# Compra
top_compra_2011 <- compra11 %>%
  arrange(desc(Compra11Mun)) %>%
  distinct(Compra11Mun, .keep_all = TRUE) |> 
  select(Compra11Mun, MUN_LITERAL, PROV_LITERAL, CCAA)

# Herencia
top_herencia_2011 <- compra11 %>%
  arrange(desc(Herencia11Mun)) %>%
  distinct(cusec, .keep_all = TRUE) |> 
  select(Herencia11Mun, MUN_LITERAL, PROV_LITERAL, CCAA)

# Alquiler
top_alquiler_2011 <- compra11 %>%
  arrange(desc(Alquiler11Mun)) %>%
  distinct(cusec, .keep_all = TRUE) |> 
  select(Alquiler11Mun, MUN_LITERAL, PROV_LITERAL, CCAA)

# Otro
top_otro_2011 <- compra11 %>%
  arrange(desc(Otro11Mun)) %>%
  distinct(cusec, .keep_all = TRUE) |> 
  select(Otro11Mun, MUN_LITERAL, PROV_LITERAL, CCAA)

top_compra_2011
top_herencia_2011
top_alquiler_2011
top_otro_2011

```

En 2021

```{r}
# Propiedad
top_propiedad_2021 <- compra21 |> 
    distinct(cusec, .keep_all = TRUE) |> 
    arrange(desc(Propiedad21Mun)) |> 
    select(Propiedad21Mun, MUN_LITERAL, PROV_LITERAL, CCAA)

# Alquiler
top_alquiler_2021 <- compra21 |> 
    distinct(cusec, .keep_all = TRUE) |> 
    arrange(desc(Alquiler21Mun)) |> 
    select(Alquiler21Mun, MUN_LITERAL, PROV_LITERAL, CCAA)

# Otro
top_otro_2021 <- compra21 |> 
    distinct(cusec, .keep_all = TRUE) |> 
    arrange(desc(Otro21Mun)) |> 
    select(Propiedad21Mun, MUN_LITERAL, PROV_LITERAL, CCAA)

top_propiedad_2021
top_alquiler_2021
top_otro_2021

```


### Por provincias

```{r}
# Compra
top_compra_2011 <- compra11 |> 
    distinct(CPRO, .keep_all = TRUE) |> 
    arrange(desc(Compra11Prov)) |> 
    select(Compra11Prov, PROV_LITERAL, CCAA)

# Herencia
top_herencia_2011 <- compra11 |> 
    distinct(CPRO, .keep_all = TRUE) |> 
    arrange(desc(Herencia11Prov)) |> 
    select(Herencia11Prov, PROV_LITERAL, CCAA)

# Alquiler
top_alquiler_2011 <- compra11 %>%
  arrange(desc(Alquiler11Prov)) %>%
  distinct(CPRO, .keep_all = TRUE) |> 
  select(Alquiler11Prov, PROV_LITERAL, CCAA)

# Otro
top_otro_2011 <- compra11 %>%
  arrange(desc(Otro11Prov)) %>%
  distinct(CPRO, .keep_all = TRUE) |> 
  select(Otro11Prov, PROV_LITERAL, CCAA)

top_compra_2011
top_herencia_2011
top_alquiler_2011
top_otro_2011


```

### 2021

```{r}

# Propiedad
top_propiedad_2021 <- compra21 |> 
    distinct(CPRO, .keep_all = TRUE) |> 
    arrange(desc(Propiedad21Prov)) |> 
    select(Propiedad21Prov, PROV_LITERAL, CCAA)

# Alquiler
top_alquiler_2021 <- compra21 |> 
    distinct(CPRO, .keep_all = TRUE) |> 
    arrange(desc(Alquiler21Prov)) |> 
    select(Alquiler21Prov, PROV_LITERAL, CCAA)

# Otro
top_otro_2021 <- compra21 |> 
    distinct(CPRO, .keep_all = TRUE) |> 
    arrange(desc(Otro21Prov)) |> 
    select(Propiedad21Mun, PROV_LITERAL, CCAA)

top_propiedad_2021
top_alquiler_2021
top_otro_2021
```

# Diferencia entre años

### Municipios

```{r}

# Propiedad
dif_propiedad_mun <- propiedad |> 
    distinct(PropiedadDifMun, .keep_all = TRUE) |> 
  arrange(desc(PropiedadDifMun)) |> 
    select(PropiedadDifMun, MUN_LITERAL, PROV_LITERAL, CCAA)

# Alquiler

dif_alquiler_mun <- propiedad %>%
    distinct(AlquilerDifMun, .keep_all = TRUE) |> 
  arrange(desc(AlquilerDifMun)) %>%
    select(AlquilerDifMun, MUN_LITERAL, PROV_LITERAL, CCAA)

# Otro

dif_otro_mun <- propiedad %>%
    distinct(OtroDifMun, .keep_all = TRUE) |> 
  arrange(desc(OtroDifMun)) %>%
    select(OtroDifMun, MUN_LITERAL, PROV_LITERAL, CCAA)
```

### Provincias

```{r}

# Propiedad
dif_propiedad_prov <- propiedad |> 
    distinct(PropiedadDifProv, .keep_all = TRUE) |> 
  arrange(desc(PropiedadDifProv)) |> 
    select(PropiedadDifProv, PROV_LITERAL, CCAA)

# Alquiler

dif_alquiler_prov <- propiedad %>%
    distinct(AlquilerDifProv, .keep_all = TRUE) |> 
  arrange(desc(AlquilerDifProv)) %>%
    select(AlquilerDifProv, PROV_LITERAL, CCAA)

# Otro

dif_otro_prov <- propiedad %>%
    distinct(OtroDifProv, .keep_all = TRUE) |> 
  arrange(desc(OtroDifProv)) %>%
    select(OtroDifProv, PROV_LITERAL, CCAA)

```

### CCAA

```{r}
# Propiedad
dif_propiedad_ccaa <- propiedad |> 
    distinct(PropiedadDifCCAA, .keep_all = TRUE) |> 
  arrange(desc(PropiedadDifCCAA)) |> 
    select(PropiedadDifCCAA, PROV_LITERAL, CCAA)

# Alquiler

dif_alquiler_prov <- propiedad %>%
    distinct(AlquilerDifProv, .keep_all = TRUE) |> 
  arrange(desc(AlquilerDifProv)) %>%
    select(AlquilerDifProv, PROV_LITERAL, CCAA)

# Otro

dif_otro_prov <- propiedad %>%
    distinct(OtroDifProv, .keep_all = TRUE) |> 
  arrange(desc(OtroDifProv)) %>%
    select(OtroDifProv, PROV_LITERAL, CCAA)

```

## Mapa diferencia provincias

```{r, fig.height=6, fig.width=12}

library(mapSpain)
  
esp_can <- esp_get_country() 
can_prov <- esp_get_can_provinces()
can_box <- esp_get_can_box() 
munic <- esp_get_munic() 
  
ccaa <- esp_get_ccaa() |> 
  mutate(codauto = codauto)

mapa <- propiedad |> 
  select(CPRO, PropiedadDifProv) |> 
  distinct(CPRO, .keep_all = TRUE)

mapa <- provic |> 
  left_join(mapa, by = "CPRO")

# Propiedad
p1 <- ggplot(esp_can) +
  geom_sf() +
  geom_sf(data = can_prov) +
  geom_sf(data = can_box) + 
  geom_sf(data = mapa, aes(fill = PropiedadDifProv), color = "black", size = 1) + 
        geom_sf_text(data = mapa, aes(label = round(PropiedadDifProv, 1)), color = "black", size = 2.5, check_overlap = TRUE, nudge_y = 0.1) +  # Agregar etiquetas
  theme_void() +  
  labs(title = "Porcentaje de propiedad por provincia 2021") +  
  theme(legend.position = c(0.18, 0.55),    
        legend.justification = "center",   
        legend.background = element_rect(fill = NULL, colour = "black"),
        legend.margin = margin(6, 6, 6, 6)) + 
  guides(fill = guide_legend(ncol = 2)) + 
  coord_sf() +
  scale_fill_gradient2(low = "red", mid = "white", high = "green", midpoint = 0)

# Alquiler
mapa <- propiedad |> 
  select(CPRO, AlquilerDifProv) |> 
  distinct(CPRO, .keep_all = TRUE)

mapa <- provic |> 
  left_join(mapa, by = "CPRO")

p2 <- ggplot(esp_can) +
  geom_sf() +
  geom_sf(data = can_prov) +
  geom_sf(data = can_box) + 
  geom_sf(data = mapa, aes(fill = AlquilerDifProv), color = "black", size = 1) + 
        geom_sf_text(data = mapa, aes(label = round(AlquilerDifProv, 1)), color = "black", size = 2.5, check_overlap = TRUE, nudge_y = 0.1) +  # Agregar etiquetas
  theme_void() +  
  labs(title = "Porcentaje de alquiler por provincia 2021") +  
  theme(legend.position = c(0.18, 0.55),    
        legend.justification = "center",   
        legend.background = element_rect(fill = NULL, colour = "black"),
        legend.margin = margin(6, 6, 6, 6)) + 
  guides(fill = guide_legend(ncol = 2)) + 
  coord_sf() +
  scale_fill_gradient2(low = "red", mid = "white", high = "green", midpoint = 0)


# Otro
mapa <- propiedad |> 
  select(CPRO, OtroDifProv) |> 
  distinct(CPRO, .keep_all = TRUE)

mapa <- provic |> 
  left_join(mapa, by = "CPRO")

p3 <- ggplot(esp_can) +
  geom_sf() +
  geom_sf(data = can_prov) +
  geom_sf(data = can_box) + 
  geom_sf(data = mapa, aes(fill = OtroDifProv), color = "black", size = 1) + 
        geom_sf_text(data = mapa, aes(label = round(OtroDifProv, 1)), color = "black", size = 2.5, check_overlap = TRUE, nudge_y = 0.1) +  # Agregar etiquetas
  theme_void() +  
  labs(title = "Porcentaje de otro por provincia 2021") +  
  theme(legend.position = c(0.18, 0.55),    
        legend.justification = "center",   
        legend.background = element_rect(fill = NULL, colour = "black"),
        legend.margin = margin(6, 6, 6, 6)) + 
  guides(fill = guide_legend(ncol = 2)) + 
  coord_sf() +
  scale_fill_gradient2(low = "red", mid = "white", high = "green", midpoint = 0)


ggarrange(p1, p2, p3, ncol=2, nrow = 2)

```


## PCA

Qué tienen estos municipios en común? Qué distingue unos de los otros? Pues vamos a ver los componentes y clusters

Con 10 componentes explicamos el 88.4% de la variabilidad; con 5, el 70%. Dos son 41.2%.

We first create a database keeping only the numeric columns which are going to contribute to our PCA analysis. We observe that with 7 components we explain 100% of variability, and with 2 we explain 65.3% of variability.

COMRPOBAR SI TODO ES NUMERICO   


### Poner provincia en municipios pequeños

```{r}
municipios <- municipios |> 
    mutate(MUN_LITERAL = ifelse(grepl("\\d", MUN_LITERAL), paste(MUN_LITERAL, PROV_LITERAL), MUN_LITERAL))


```

pca

```{r, fig.height=6, fig.width=12}

todopropiedad <- propiedad |> 
  select(cusec, Propiedad21Mun, Alquiler21Mun, Otro21Mun, Propiedad11Mun, Herencia11Mun, Alquiler11Mun, Otro11Mun, PropiedadDifMun, AlquilerDifMun, OtroDifMun)

municipios <- municipios |> 
  select(-Propiedad21Mun, -Alquiler21Mun, -Otro21Mun, -Compra11Mun, -Herencia11Mun, -Alquiler11Mun, -Otro11Mun, -PropiedadDifMun, -AlquilerDifMun) |> 
  left_join(todopropiedad, by = "cusec") 

municipios <- municipios |> 
  select(-OtroDifMun.x) |> 
  mutate(OtroDifMun = OtroDifMun.y)

municipios <- municipios |> 
  select(MUN_LITERAL, PROV_LITERAL, CCAA, PropiedadDifMun, AlquilerDifMun, OtroDifMun, Herencia11Mun, RentaMedia2021, PorcentajeJoven2021, PorcentajeJovenDif, PorcentajeVacias2021, PorcentajeSecundarias2021, PorcentajeEspañola, PorcentajeProtegidas2021, ProtegidaDif,PrecioAlquilerM2)


# Keeping the names of municipalities and CCAA
names = municipios$MUN_LITERAL
prov = municipios$PROV_LITERAL
ccaa = municipios$CCAA

# Creating only numeric database
numeric_data <- municipios %>%
  ungroup() |> 
  select_if(is.numeric) 


# Creating the components
set.seed(123)
pca = prcomp(numeric_data, scale=T)
summary(pca)

# Plot of the variability explained by components
fviz_screeplot(pca, addlabels = TRUE)
```


### Analizar cada componente

*Componente 1*. Las variables que más contribuyen a este componente es PorcentajeVacías2021, PorcentajeSecundarias2021, PrecioAlquilerM2 y PorcentajeProtegidas2021. Son variables relacionadas con el mercado de vivienda en sí de los municipios, no tiene relación cosas como la diferencia en regímenes de tenencia o características de la población juvenil.

- PorcentajeVacías2021. Muy alto porcentaje de viviendas vacías.
- PorcentajeSecundarias2021. Muy alto porcentaje de viviendas secundarias.
- PrecioAlquilerM2. Muy bajo el precio de alquiler.
- PorcentajeProtegidas2021. Muy pocas viviendas protegidas.
- PropiedadDifMun. Aumento significativo de la propiedad en el municipio.
- AlquilerDifMun. Gran descenso del alquiler.
- OtroDifMun. Ligero aumento de 'otro'.
- Herencia11Mun. Bastante herencia de viviendas principales en los municipios.

Los municipios con más puntuación en este componente son municipios muy pequeños de Ourense y Lugo. Son municipios rurales con pocas personas jóvenes residentes, con gran cantidad de viviendas secundarias o vacías, bajo precio... También vemos que tienen más herencia que otros municipios, gran reducción del alquiler y aumento de la propiedad y de 'Otro'.

Por otra parte, los municipios con menor puntuación son municipios con muy pocas viviendas vacías, un alquiler caro, o además con muchas viviendas protegidas como Ceuta. Tampoco han experimentado un aumento de la propiedad significativo.


```{r, fig.height=6, fig.width=12}

# Contribution of variables to component 1
fviz_contrib(pca, choice = "var", axes = 1)

# Plot adjustments
n <- 10
col_pos <- colorRampPalette(c("#CCE6CC", "#208909"))(n)
col_neg <- colorRampPalette(c("#FFE6E6", "#B30000"))(n)
coefs <- pca$rotation[,1]
valor_max <- max(coefs)
valor_min <- min(coefs)
coefs_ajustados <- coefs - valor_min + 1
colores <- ifelse(coefs >= 0, col_pos[ceiling((coefs_ajustados / (valor_max - valor_min + 1)) * n)], 
                  col_neg[ceiling((abs(coefs_ajustados) / (valor_max - valor_min + 1)) * n)])

# Plot
barplot(coefs, las = 2, col = colores, cex.names = 0.8)

#Ranking of municipalities of this component
names[order(pca$x[,1], decreasing=T)][1:5]
names[order(pca$x[,1])][1:5]


```

*Componente 2*. Las variables más relevantes en el componente 2 es PropiedadDifMun, OtroDifMun, ProtegidaDif, PorcentajeProtegidas2021. Básicamente, ahora sí entran en juego los regímenes de tenencia.

- PropiedadDifMun. Ha aumentado muchísimo la propiedad.
- OtroDifMun. Se ha reducido mucho el régimen 'Otro'. 
- ProtegidaDif. Se ha reducido mucho las viviendas protegidas.
- PorcentajeProtegidas2021. La cantidad de viviendas protegidas es alta.
- PorcentajeJovenDif. Un aumento de la cantidad de jóvenes.
- PrecioAlquilerM2. Un precio mediano del alquiler.

Los municipios con mayor puntuación son Ceuta, Zarautz, Pozuelo de Alarcón y Nerja. Estos primeros 3 municipios no tienen un aumento muy significativo de la propiedad, si bien por lo menos no es un descenso. Lo que hace que aparezcan aquí es la cantidad de viviendas protegidas. Este valor es por CCAA, no por municipio. Con lo cual, parece que este componente está agrupando a muchos municipios de la misma CCAA (Madrid, Navarra) sólo por tener ese valor de viviendas protegidas, y porque no tienen un descenso en la propiedad. 

En el caso de Nerja y Jaén, es el caso contrario: aparecen por un gran aumento en la propiedad pero la cantidad de viviendas protegidas es reducida.

```{r, fig.height=6, fig.width=12}

# Contribution of variables to component 1
fviz_contrib(pca, choice = "var", axes = 2)

# Plot adjustments
coefs <- pca$rotation[,2]
valor_max <- max(coefs)
valor_min <- min(coefs)
coefs_ajustados <- coefs - valor_min + 1
colores <- ifelse(coefs >= 0, col_pos[ceiling((coefs_ajustados / (valor_max - valor_min + 1)) * n)], 
                  col_neg[ceiling((abs(coefs_ajustados) / (valor_max - valor_min + 1)) * n)])

# Plot
barplot(coefs, las = 2, col = colores, cex.names = 0.8)

#Ranking of municipalities of this component
names[order(pca$x[,2], decreasing=T)][1:5]
names[order(pca$x[,2])][1:5]

```

### Plot de componentes

Ahora podemos analizar el siguiente gráfico que posiciona los municipios en los ejes según su puntuación en cada uno de los dos primeros componentes. 

P1: Muchas vacías, secundarias, muy pocas protegidas, alquiler bajo, aumento propiedad y mucho descenso alquiler

P2: Mucha vivienda protegida, mucho aumento propiedad

Con respecto al eje X, del PC1, vemos que a la derecha se encuentran municipios con más puntuación. Son municipios con muchas viviendas vacías o secundarias, así como un aumento de la propiedad. Están pequeños pueblos gallegos, de las islas, andaluces, y otras provincias que no son capitales de comunidad. En la izquierda vemos municipios con muy pocas viviendas secundarias/vacías, o sea, pocas viviendas 'que sobren'. Municipios madrileños caros, con renta alta. También País Vasco, Cataluña... Conforme nos acercamos de la izquierda al centro vemos municipios que se van alejando de esta definición, pero siguen siendo ciudades 'relevantes', con bastante ocupación de las viviendas: albacete, Granada, El Ejido. Destaca el caso de Ceuta por su poca cantidad de viviendas vacías y secundarias debido a su poco territorio, así como un precio de alquiler que entraría en el 20% más caro de todos los municipios.

En el eje Y, PC2, se centra más en la presencia de vivienda protegida y aumento de la propiedad. También en aumento de personas jóvenes y precio mediano de alquiler. Ceuta se posiciona en primer lugar por ser el municipio con más cantidad de vivienda protegida. También tiene un aumento en la propiedad (si bien es ligero). Por otra parte, vemos que los municipios se sitúan todos en una posición del eje Y similar, no hay tantas diferencias como en el primer componente. El municipio con menor puntuación es pueblos de menos de 2000-5000 habitantes de Las Palmas, con poca vivienda protegida y un gran descenso de la propiedad.

```{r, fig.height=7, fig.width=14}
p <-data.frame(z1 = pca$x[,1], z2 = pca$x[,2]) %>%
  ggplot(aes(z1, z2, label = names, color = ccaa)) +
  geom_point(size = 0) +
  labs(title = "First two principal components (scores)", x = "PC1", y = "PC2") +  theme_bw() +   theme(legend.position = "bottom") +
  geom_text(size = 3, hjust = 0.6, vjust = 0, check_overlap = T)

p

# Versión interactiva
ggplotly(p)

```

### Aplly clustering tools and interpret

Usando el método wss y silhouette sugiere utilizar 3 clusters. Con gap_stat sugiere 6.

```{r}

#fviz_nbclust(scale(numeric_data), kmeans, method = 'wss', k.max = 20, nstart = 1000)

#fviz_nbclust(scale(numeric_data), kmeans, method = 'silhouette', k.max = 20, nstart = 1000)

#fviz_nbclust(scale(numeric_data), kmeans, method = 'gap_stat', k.max = 10, nstart = 100, nboot = 100)

```

Qué es cada cluster

Cluster 1. Municipios con poco descenso de propiedad (-10%), descenso moderado del alquiler y gran descenso de 'Otro'. Baja herencia en 2011. Alta renta media, bastante personas jóvenes e incuso aumento de juventud. Pocas viviendas vacías y secundarias, poca población española, bastantes viviendas protegidas pero gran descenso (si hay más viviendas, lógico que el descenso sea mayor). Renta media alta.

Algunos ejemplos de este cluster, ordenados de más aumento de propiedad a menos, son 

Ver ejemplos y ver si lo cumplne. Podemos idstuinguir aumento distinto entre municipios muy chicos, y municipios pijos?

Tal vez poner mi variable binaria de Propiedad?   
```{r}

set.seed(123)
fit <- kmeans(numeric_data, centers=3, nstart = 100)
fit

numeric_data$cluster <- fit$cluster
centers=fit$centers

# Todo normal, no normalizo nada, pero al calcular los centers sí lo hago para poder interpretar el barplot
scaled_centers <- scale(fit$centers)

barplot(scaled_centers[1,], las=2, col="#097969")
barplot(scaled_centers[2,], las=2, col="#097969")
#-

barplot(centers[1,], las=2, col="#097969")
barplot(centers[2,], las=2, col="#097969")
barplot(centers[3,], las=2, col="#097969")

fviz_cluster(fit, data = numeric_data, geom = c("point"),ellipse.type = 'norm', pointsize=1)+
  theme_minimal()+geom_text(label=names,hjust=0, vjust=0,size=2,check_overlap = T)+scale_fill_brewer(palette="Paired")


```



# Peso a varibale objetivo

### Solo normalizar todo
Si hago esto así, la varianza explicada es similar etc. me sale un clustlot un poco raro con municipios super outliers. Para ver si es más útil así tendría que analizarlo. 

```{r}

# normalizar
numeric_data <- scale(numeric_data)
numeric_data <- as.data.frame(numeric_data)

pca = prcomp(numeric_data, scale=T)
summary(pca)

# Plot of the variability explained by components
fviz_screeplot(pca, addlabels = TRUE)


fit <- kmeans(numeric_data, centers = 3, nstart = 100)
fit

numeric_data$cluster <- fit$cluster

centers=fit$centers

barplot(centers[1,], las=2, col="#097969")
barplot(centers[2,], las=2, col="#097969")
barplot(centers[3,], las=2, col="#097969")


```


Normalizo y hago que la variable objetivo tenga más importancia. Sino, me salen medias super parecidas de cada variable y no es útil. Ahora sí me salen cosas interesantes.

```{r}

numeric_data <- scale(numeric_data)
numeric_data <- as.data.frame(numeric_data)

# Asignar la variable de importancia
numeric_data$Importance <- numeric_data$PropiedadDifMun

# Normalizar todas las variables, excluyendo la columna de la importancia
normalized_numeric_data <- numeric_data
normalized_numeric_data[, -ncol(normalized_numeric_data)] <- scale(normalized_numeric_data[, -ncol(normalized_numeric_data)])

# Multiplicar cada variable por su peso de importancia
weighted_normalized_numeric_data <- normalized_numeric_data

weighted_normalized_numeric_data[, -ncol(weighted_normalized_numeric_data)] <- weighted_normalized_numeric_data[, -ncol(weighted_normalized_numeric_data)] * numeric_data$Importance


```

### PCA

Los dos primeros componentes explican el 48.7%.

```{r}

pca = prcomp(numeric_data, scale=T)
summary(pca)

# Plot of the variability explained by components
fviz_screeplot(pca, addlabels = TRUE)

```

*Componente 1*. 

```{r}
fviz_contrib(pca, choice = "var", axes = 1)

# Plot adjustments
n <- 10
col_pos <- colorRampPalette(c("#CCE6CC", "#208909"))(n)
col_neg <- colorRampPalette(c("#FFE6E6", "#B30000"))(n)
coefs <- pca$rotation[,1]
valor_max <- max(coefs)
valor_min <- min(coefs)
coefs_ajustados <- coefs - valor_min + 1
colores <- ifelse(coefs >= 0, col_pos[ceiling((coefs_ajustados / (valor_max - valor_min + 1)) * n)], 
                  col_neg[ceiling((abs(coefs_ajustados) / (valor_max - valor_min + 1)) * n)])

# Plot
barplot(coefs, las = 2, col = colores, cex.names = 0.8)

#Ranking of municipalities of this component
names[order(pca$x[,1], decreasing=T)][1:5]
names[order(pca$x[,1])][1:5]

```

componente 2

```{r}
# Contribution of variables to component 1
fviz_contrib(pca, choice = "var", axes = 2)

# Plot adjustments
coefs <- pca$rotation[,2]
valor_max <- max(coefs)
valor_min <- min(coefs)
coefs_ajustados <- coefs - valor_min + 1
colores <- ifelse(coefs >= 0, col_pos[ceiling((coefs_ajustados / (valor_max - valor_min + 1)) * n)], 
                  col_neg[ceiling((abs(coefs_ajustados) / (valor_max - valor_min + 1)) * n)])

# Plot
barplot(coefs, las = 2, col = colores, cex.names = 0.8)

#Ranking of municipalities of this component
names[order(pca$x[,2], decreasing=T)][1:5]
names[order(pca$x[,2])][1:5]

```

plot componentes

```{r}
p <-data.frame(z1 = pca$x[,1], z2 = pca$x[,2]) %>%
  ggplot(aes(z1, z2, label = names, color = ccaa)) +
  geom_point(size = 0) +
  labs(title = "First two principal components (scores)", x = "PC1", y = "PC2") +  theme_bw() +   theme(legend.position = "bottom") +
  geom_text(size = 3, hjust = 0.6, vjust = 0, check_overlap = T)

p

# Versión interactiva
ggplotly(p)

```

###cLusters

```{r}
fviz_nbclust(scale(weighted_numeric_data), kmeans, method = 'wss', k.max = 20, nstart = 1000)

fviz_nbclust(scale(weighted_numeric_data), kmeans, method = 'silhouette', k.max = 20, nstart = 1000)

fviz_nbclust(scale(weighted_numeric_data), kmeans, method = 'gap_stat', k.max = 10, nstart = 100, nboot = 100)

```

```{r}

# Realizar el clustering con los datos ponderados
fit <- kmeans(numeric_data, centers = 3, nstart = 100)
fit

numeric_data$cluster <- fit$cluster

scaled_centers <- scale(fit$centers)

# Crear los gráficos de barras con las variables estandarizadas
barplot(scaled_centers[1,], las=2, col="#097969")
barplot(scaled_centers[2,], las=2, col="#097969")

centers=fit$centers

barplot(centers[1,], las=2, col="#097969")
barplot(centers[2,], las=2, col="#097969")
barplot(centers[3,], las=2, col="#097969")


```

Clusplot

```{r, fig.height=6, fig.width=12}

fviz_cluster(fit, data = numeric_data, geom = c("point"),ellipse.type = 'norm', pointsize=1)+
  theme_minimal()+geom_text(label=names,hjust=0, vjust=0,size=2,check_overlap = T)+scale_fill_brewer(palette="Paired")

```

Realmente los clusters no me están explicando tanto.

## Modelo

Vale, entonces cómo influye cada variable exactamente en el reg de tenencia?


Primero probamos un modelo con todas las variables menos las relativas a la proporción de regímenes de tenencia. En el modelo 1, tenemos un R cuadrado de 0.3 y muchas variables no significativas o incluso con NA por una fuerte multicolinealidad.

En el modelo 2 añadimos los regímenes de tenencia en 2011. En este caso el R cuadrdado pasa a ser 0.51. Este modelo intentaría explicar el cambio en la Propiedad en 2021 desde 2011 a partir de los datos de regímenes de tenencia en 2011 y el resto de variables independientes, sin dar información de los regímenes en 2021 para que no se autocorrelacione.

Modelo 3, quitamos variables no significativas, 0.46 R cuadrado. Los coeficientes que me salen sono casi todos negativos, es difícil de interpretar.

```{r}
# Preparar datos
municipios <- read_xlsx("municipios.xlsx")
propiedad <- read_xlsx("propiedad.xlsx")

municipios <- municipios |> 
    mutate(MUN_LITERAL = ifelse(grepl("\\d", MUN_LITERAL), paste(MUN_LITERAL, PROV_LITERAL), MUN_LITERAL))

todopropiedad <- propiedad |> 
  select(cusec, Propiedad21Mun, Alquiler21Mun, Otro21Mun, Propiedad11Mun, Herencia11Mun, Alquiler11Mun, Otro11Mun, PropiedadDifMun, AlquilerDifMun, OtroDifMun)

municipios <- municipios |> 
  select(-Propiedad21Mun, -Alquiler21Mun, -Otro21Mun, -Compra11Mun, -Herencia11Mun, -Alquiler11Mun, -Otro11Mun, -PropiedadDifMun, -AlquilerDifMun) |> 
  left_join(todopropiedad, by = "cusec") 

municipios <- municipios |> 
  select(-OtroDifMun.x) |> 
  mutate(OtroDifMun = OtroDifMun.y)

municipios <- municipios |> 
  mutate(SecundariasDif=PorcentajeSecundarias2021-PorcentajeSecundarias2011)

numeric_data <- municipios %>%
  ungroup() |> 
  select_if(is.numeric) 


# Modelo 1 - Todas las variables sin regímenes de tenencia
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipv2021General, ipv2021Nueva, ipv2021Segunda, ipv2011General, ipv2011Nueva, ipv2011Segunda, RentaMedia2021, PorcentajeJoven2011, PorcentajeJoven2021, PorcentajeJovenDif, PorcentajeVacias2011, PorcentajeVacias2021, PorcentajeSecundarias2011, PorcentajeSecundarias2021, PorcentajeTurísticas2021, PorcentajeEspañola2021, PorcentajeEuropea2021, PorcentajeNoEuropea2021, PrecioHipoteca2021Prov, PrecioHipoteca2011Prov, DifPrecioHipotecaProv, ParoJuvenil2021, ParoJuvenil2011, PorcentajeProtegidas2011, PorcentajeProtegidas2021, ProtegidaDif, PrecioAlquilerM2)

modelo <- lm(PropiedadDifMun ~ ., data = independientes)
summary(modelo)
 
# Modelo 2 - Todas las variables con regímenes de tenencia 2011
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipv2021General, ipv2021Nueva, ipv2021Segunda, ipv2011General, ipv2011Nueva, ipv2011Segunda, RentaMedia2021, PorcentajeJoven2011, PorcentajeJoven2021, PorcentajeJovenDif, PorcentajeVacias2011, PorcentajeVacias2021, PorcentajeSecundarias2011, PorcentajeSecundarias2021, PorcentajeTurísticas2021, PorcentajeEspañola2021, PorcentajeEuropea2021, PorcentajeNoEuropea2021, PrecioHipoteca2021Prov, PrecioHipoteca2011Prov, DifPrecioHipotecaProv, ParoJuvenil2021, ParoJuvenil2011, PorcentajeProtegidas2011, PorcentajeProtegidas2021, ProtegidaDif, PrecioAlquilerM2, Propiedad11Mun, Herencia11Mun, Alquiler11Mun, Otro11Mun)

modelo <- lm(PropiedadDifMun ~ ., data = independientes)
summary(modelo)


# Modelo 3 - Variables significativas con regímenes de tenencia 2011
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipv2021Segunda, ipv2011General, ipv2011Segunda, PorcentajeJoven2021, PorcentajeJovenDif, PorcentajeVacias2021, PorcentajeSecundarias2021, PorcentajeTurísticas2021, PrecioHipoteca2021Prov, PrecioHipoteca2011Prov, DifPrecioHipotecaProv, ParoJuvenil2011, ProtegidaDif, Propiedad11Mun, Herencia11Mun, Alquiler11Mun)

modelo <- lm(PropiedadDifMun ~ ., data = independientes)
summary(modelo)


```

Este modelo no incluyen información de los regímenes de tenencia en 2011. Los coeficientes parecen tener sentido, pero el R cuadrado es bajo.

```{r}
# Modelo 3 - Sólo significativas
independientes <- numeric_data |> 
  select(PropiedadDifMun, RentaMedia2021, PorcentajeJoven2021, PorcentajeJovenDif, PorcentajeVacias2021, PorcentajeSecundarias2021, PorcentajeEspañola, PorcentajeProtegidas2021, ProtegidaDif, PrecioAlquilerM2)

modelo <- lm(PropiedadDifMun ~ ., data = independientes)

summary(modelo)


```

Vamos a intentar hacer un modelo poniendo todas las variables de 'diferencia' si es posible. 

Diferencia IPV? siempre es aumento (o no?)
Buscar


```{r}
independientes <- numeric_data |> 
  select(ipv2021General, ipv2021Nueva, ipv2021Segunda, ipv2011General, ipv2011Nueva, ipv2011Segunda, RentaMedia2021, PorcentajeJoven2011, PorcentajeVacias2011, PorcentajeSecundarias2011, PorcentajeSecundarias2021, PorcentajeTurísticas2021, PorcentajeEspañola, PrecioHipoteca2011Prov, DifPrecioHipotecaProv, ParoJuvenil2021, PorcentajeProtegidas2011, PorcentajeProtegidas2021, PrecioAlquilerM2, Herencia11Mun, Alquiler11Mun, Otro11Mun)

modelo <- lm(PropiedadDifMun ~ ., data = independientes)

summary(modelo)


```


### Modelo precio alquiler

```{r}

independientes <- numeric_data |> 
  select(ipv2021General, ipv2021Nueva, ipv2021Segunda, ipv2011General, ipv2011Nueva, ipv2011Segunda, RentaMedia2021, PorcentajeJoven2011, PorcentajeVacias2011, PorcentajeSecundarias2011, PorcentajeSecundarias2021, PorcentajeTurísticas2021, PorcentajeEspañola, PrecioHipoteca2011Prov, DifPrecioHipotecaProv, ParoJuvenil2021, PorcentajeProtegidas2011, PorcentajeProtegidas2021, PrecioAlquilerM2, Herencia11Mun, Alquiler11Mun, Otro11Mun)



# Modelo para explicar precio alquiler con 0.83 R2
modelo <- lm(PrecioAlquilerM2 ~ ., data = independientes)

summary(modelo)

```

# Modelo de Nuevo Tipo

Bloques de variables.
- Población
  - PorcentajeJoven
  - PorcentajeEspañola
  - PorcentajeEuropea
  - PorcentajeNoEuropea
  - ParoJuvenil
  - RentaMedia
- Mercado de vivienda
  - PorcentajeVacias
  - PorcentajeSecundarias
  - PorcentajeTurísticas
  - PorcentajeProtegidas
- Precio de vivienda
  - ipv
  - PrecioHipoteca
  - PrecioAlquilerM2
- Régimen de tenencia
  - Herencia11Mun
  
Aumento de poblacion?

```{r}

# Modelo 1 - Sólo Diferencias
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipvGeneralDif, PorcentajeJovenDif, VaciasDif, SecundariasDif, PorcentajeEspañolaDif, PorcentajeEuropeaaDif, PorcentajeNoEuropeaDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, RentaMedia2021, PorcentajeTurísticas2021, PrecioAlquilerM2, Herencia11Mun)

modelo <- lm(PropiedadDifMun ~ ., data = independientes)
summary(modelo)

# Modelo 2 - Diferencias y 2021
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipvGeneralDif, PorcentajeJovenDif, VaciasDif, SecundariasDif, PorcentajeEspañolaDif, PorcentajeEuropeaaDif, PorcentajeNoEuropeaDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, RentaMedia2021, PorcentajeTurísticas2021, PrecioAlquilerM2, Herencia11Mun, ipv2021General, PorcentajeJoven2021, PorcentajeVacias2021, PorcentajeSecundarias2021, PorcentajeEspañola2021, PorcentajeEuropea2021, PorcentajeNoEuropea2021, PrecioHipoteca2021Prov, ParoJuvenil2021, PorcentajeProtegidas2021)

modelo <- lm(PropiedadDifMun ~ ., data = independientes)
summary(modelo)

# Modelo 3 - Diferencias y 2011

independientes <- numeric_data |> 
  select(PropiedadDifMun, ipvGeneralDif, PorcentajeJovenDif, VaciasDif, SecundariasDif, PorcentajeEspañolaDif, PorcentajeEuropeaaDif, PorcentajeNoEuropeaDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, RentaMedia2021, PorcentajeTurísticas2021, PrecioAlquilerM2, Herencia11Mun, ipv2011General, PorcentajeJoven2011, PorcentajeVacias2011, PorcentajeSecundarias2011, PorcentajeEspañola2011, PorcentajeEuropea2011, PorcentajeNoEuropea2011, PrecioHipoteca2011Prov, ParoJuvenil2011, PorcentajeProtegidas2011)

modelo <- lm(PropiedadDifMun ~ ., data = independientes)
summary(modelo)



```

Qué variables dif no son significativas pero sí lo son en 21?

Sólo diferencias R2 de 0.17, pierdo info.

- ipvGeneralDif -> 2021 sí lo es
- PorcentajeEspañolaDif -> 2021 no
- PorcentajeEuropeaaDif -> 2021 no
- PorcentajeNoEuropeaDif -> 2021 no
- DifPrecioHipotecaProv -> si en este punto cambio ipv a 2021 y quito nacionalidad tiene 0.07 de p valor. 2021 es mucho menos significativo, así que no lo cambio finalmente.

En este punto, de todas mis variables he perdido sólo las nacionalidades. Sólo me queda no significativa ahora PorcentajeJovenDif.

- PorcentajeJovenDif -> 2021 no lo es ni 2011. Mantengo dif aunque no es significativa por poco.

R2 es 017.

Modelo 6.
Si quito nacionalidades española y europea, no europea dif pasa a ser significativa. Entonces, PorcentajeJoven Dif sí lo es también, pero RentaMedia2021 no.

Quito RentaMedia2021. 

- PrecioAlquilerM2. No es significativa. La quito.
- DifPrecioHipotecaProv. No es significativa. 2021 menos. la quito

Ya todo sí. Pierdo nacionalidades española, europea, RentaMedia2021, PrecioAlquilerM2, DifPrecioHipotecaProv. Está claro que nacionalidad no europea se relaciona con estas cosas de precios y renta. Prefiero quedarme con el modelo 4 porque es más fácil de interpretar ese modelo que digamos explica lo mismo que no europea pero en 3 variables más comprensibles.

```{r}
# Modelo 4 - Dif, 2021 y significativas de éstas

# original solo dif y las q me faltan en 2021
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipvGeneralDif, PorcentajeJovenDif, VaciasDif, SecundariasDif, PorcentajeEspañolaDif, PorcentajeEuropeaaDif, PorcentajeNoEuropeaDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, RentaMedia2021, PorcentajeTurísticas2021, PrecioAlquilerM2, Herencia11Mun)

# sólo dif, las que me faltan en 2021 y dif no sgnificativas las pongo en 2021: Añado ipv2021 y quito nacionalidades
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipv2021General, PorcentajeJovenDif, VaciasDif, SecundariasDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, RentaMedia2021, PorcentajeTurísticas2021, PrecioAlquilerM2, Herencia11Mun)

modelo4 <- lm(PropiedadDifMun ~ ., data = independientes)
summary(modelo4)

# Sólo dif, las que me faltan en 2021 y dif no sgnificativas las pongo en 2021. Añado ipv2021, quito nacionalidades menos noeuropea, quito renta, precioalquiler y difpreciohipoteca.
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipv2021General, PorcentajeJovenDif, VaciasDif, SecundariasDif, ParoJuvenilDif, ProtegidaDif, PorcentajeTurísticas2021, Herencia11Mun, PorcentajeNoEuropeaDif)

modelo6 <- lm(PropiedadDifMun ~ ., data = independientes)
summary(modelo6)

```

Qué variables dif no son significativas pero sí lo son en 11?

Sólo diferencias R2 de 0.17, pierdo info.

- ipvGeneralDif -> 2011 sí lo es
- PorcentajeEspañolaDif -> 2011 no. Pero al ponerla, NoEuropeaDif sí lo es. o si quito dif.
- PorcentajeEuropeaaDif -> 2011 no
- PorcentajeNoEuropeaDif -> Al quitar las nacionalidades anteriores sí es significaativa.
- DifPrecioHipotecaProv -> 2011 sí es.

En este punto, de todas mis variables he perdido sólo las nacionalidades española y europea. Sólo me queda no significativa ahora RentaMedia2021 y PrecioAlquilerM2.

- PrecioAlquilerM2. Lo quito. Renta sigue sin ser sidnigicativa y ipv pasa a dejar de serlo. ipvdif tampoco lo es.
- RentaMedia2021. lo qito también. No es significativo ipv.

Si quito ipv, todo significativo. 0.17 R2

Pierdo info de nacionalidades española, europea, precioalquilerm2, rentamedia2021 e ipv.

En este caso no es como en 2021, que si quito Europea éstas son significativas. No lo son, pasan a no serlo bastantes. Por lo que creo que el modelo 5 es el mejor de 2011.

```{r}
# Modelo 5 - Dif, 2011 y significativas de éstas

# original solo dif y las q me faltan en 2021
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipvGeneralDif, PorcentajeJovenDif, VaciasDif, SecundariasDif, PorcentajeEspañolaDif, PorcentajeEuropeaaDif, PorcentajeNoEuropeaDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, RentaMedia2021, PorcentajeTurísticas2021, PrecioAlquilerM2, Herencia11Mun)

modelo <- lm(PropiedadDifMun ~ ., data = independientes)
summary(modelo)

# sólo dif, las que me faltan en 2021 y significativas
independientes <- numeric_data |> 
  select(PropiedadDifMun, PorcentajeJovenDif, VaciasDif, SecundariasDif, PorcentajeNoEuropeaDif, PrecioHipoteca2011Prov, ParoJuvenilDif, ProtegidaDif, PorcentajeTurísticas2021, Herencia11Mun)

modelo5 <- lm(PropiedadDifMun ~ ., data = independientes)
summary(modelo5)
```


Creo que el mejor modelo es el 4. Utilizo en la mayor medida posible las diferencias, y cuando éstas no son significativas, utilizo los datos del 2021. Esto me permite decir: cuando en 2021 (la "actualidad") el IPV es más alto, eso puede contribuir en x cantidad a que sea menor la propiedad (por ejemplo, es una conjetura). Es decir, esta característica actual contribuye en tal forma a la variable dependiente. Creo que es más útil que decir 'cuando en 2011 esta variable es tal, los municipios ahora se ven favorecidos en tal...'. Además, el modelo 4 sólo pierde información de las nacionalidades, que son variables que quizá se explican peor que otras más concretas. Prefiero perder esas ante la multicolinealidad que otras.

# Multicolinealidad y heterocedasticidad

En el modelo 4 los valores de todas las variables son menores a 5, descartando la existencia de una multicolinealidad fuerte. Tiene sentido porque ya hemos quitado otras variables que no eran significativas, precisamente, por multicolinealidad seguramente. Sólo ipv2021General y PrecioAlquilerM2 presentan un valor más alto, ambas se refieren al precio de la vivienda. 

```{r}

vif(modelo4)
```


### Heterocedasticidad

Dado que los resultados del bp test da un p valor muy bajo, nos confirma que existe heterocedasticidad. En el gráfico de residuos vemos que los puntos se reparten alrededor de la línea del centro del eje y, 0, y tiene una forma más bien simétrica: hay más o menos los mismos puntos tanto debajo como encima de la línea. Con respecto al eje X, sí se observa que hay mayor variabilidad a la derecha, pareciendo ser valores atípicos. Estos puntos parecen corresponderse con los casos en los que aumenta la propiedad. Como son pocos casos el modelo no los predice tan bien y se observan un poco como outliers. A pesar de esto, no vemos formas muy raras o desajustes muy grandes, por lo que parece que más o menos se ajustan bien los residuos, a pesar de la existencia de heterocedasaticidad. O sea, no vemos cosas muy raras, sino la heterocedasticidad esperable por relaciones no lineales y la cuestión de que hay peor ajuste con los casos donde sí ha aumentado la propiedad.

Con respecto al eje Y, sí vemos que hay cierta tendencia a asignar un valor predicho más bajo del real. De nuevo, porque hay muchos menos casos de cambio negativo que positivo. Pero si pruebo un modelo con solo las filas negativas es peor.
```{r}
#bp test
bptest(modelo4)

#residuos estandarizados
residuos_estandarizados <- rstandard(modelo4)  
valores_ajustados <- fitted(modelo4)         

plot(valores_ajustados, residuos_estandarizados,
     xlab = "Valores Ajustados", ylab = "Residuos Estandarizados",
     main = "Gráfico de Residuos Estándar vs. Valores Ajustados")
abline(h = 0, col = "red", lty = 2)         

```

Probando a normalizar las variables, me sale la misma heterocedasticidad. Probablemente se debe simplemente a que hay relaciones no lineales entre algunas variables independientes y la dependiente.

```{r}

independientes <- numeric_data |> 
  select(PropiedadDifMun, ipv2021General, PorcentajeJovenDif, VaciasDif, SecundariasDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, RentaMedia2021, PorcentajeTurísticas2021, PrecioAlquilerM2, Herencia11Mun)

library(caret)

# Selecciona todas las columnas de tu base de datos 'independientes'
columnas_numericas <- sapply(independientes, is.numeric)

# Normaliza todas las columnas utilizando el método Min-Max
proceso_normalizacion <- preProcess(independientes[, columnas_numericas], method = c("range"))
independientes_normalizados <- predict(proceso_normalizacion, independientes[, columnas_numericas])


modelo4 <- lm(PropiedadDifMun ~ ., data = independientes_normalizados)
summary(modelo4)


residuos_estandarizados <- rstandard(modelo4)  
valores_ajustados <- fitted(modelo4)         

plot(valores_ajustados, residuos_estandarizados,
     xlab = "Valores Ajustados", ylab = "Residuos Estandarizados",
     main = "Gráfico de Residuos Estándar vs. Valores Ajustados")
abline(h = 0, col = "red", lty = 2)         



```

### Normalidad

El test de shapiro-wilk da un valor menor a 0.05, lo que nos dice que los datos no siguen una distribución normal.

Sin embargo, en el QQ plot vemos que los datos se ajustan mayoritariamente de forma perfecta a la línea, pero en el principio y el final se desvían de forma simétrica: al principio los valores que se separan de la línea van hacia abajo, y al final van hacia arriba. Parece seguir una distribución normal o 'light tailed'. Esto se relaciona con tener menos valores extremos que una distribución normal.

La desviación estándar de la variable PropiedadDifMun es de 1.32.

```{r}
#qq plot
residuos <- resid(modelo4)

qqnorm(residuos)
qqline(residuos)
shapiro.test(residuos)

  
```


### Transformando variables

Si pruebo el grafico de residuos en un modelo que solo usa el ipv, se ven lineas verticales rectas, porque son datos agrupados por ccaa.

Si pongo un modelo de solo las filas positivas el r cuadrado aumenta a 0.36 pero se ve heterocedasticidad. Simplemente un modelo de 53 observaciones es poco fiable.

```{r}


#modelo original
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipv2021General, PorcentajeJovenDif, VaciasDif, SecundariasDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, RentaMedia2021, PorcentajeTurísticas2021, PrecioAlquilerM2, Herencia11Mun)

#transformación
independientes <- subset(independientes, PropiedadDifMun > 0)

modelo4b <- lm(PropiedadDifMun ~ ., data = independientes)
summary(modelo4b)

# heterocedasticidad
bptest(modelo4b)

residuos_estandarizados <- rstandard(modelo4b)  
valores_ajustados <- fitted(modelo4b)         
plot(valores_ajustados, residuos_estandarizados,
     xlab = "Valores Ajustados", ylab = "Residuos Estandarizados",
     main = "Gráfico de Residuos Estándar vs. Valores Ajustados")
abline(h = 0, col = "red", lty = 2)         


```

si hago log de propiedad. pues no se, no lo se interpretar bien, no tiene sentido cambiar la variable dependiente creo yo
```{r}
#modelo original
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipv2021General, PorcentajeJovenDif, VaciasDif, SecundariasDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, RentaMedia2021, PorcentajeTurísticas2021, PrecioAlquilerM2, Herencia11Mun)

#transformación

independientes <- independientes |> 
  mutate(PropiedadDifMun = log(PropiedadDifMun))

modelo4b <- lm(PropiedadDifMun ~ ., data = independientes)
summary(modelo4b)

# heterocedasticidad
bptest(modelo4b)

residuos_estandarizados <- rstandard(modelo4b)  
valores_ajustados <- fitted(modelo4b)         
plot(valores_ajustados, residuos_estandarizados,
     xlab = "Valores Ajustados", ylab = "Residuos Estandarizados",
     main = "Gráfico de Residuos Estándar vs. Valores Ajustados")
abline(h = 0, col = "red", lty = 2)  
```

cambiar totras muchas variables

- PrecioAlquilerM2^2. Lo elevo al cuadrado. Es significativa y además me explica bastante: un aumento en el precio del alquiler tiende a mostrar una pérdida de propiedad, pero un GRAN aumento en el mismo muestra un aumento. Es lo que pasa en Pozuelos, Alcobendas... Distinguiendo de nuevo estos dos grupos donde ha aumentado, los pueblos pequeños donde es barato y hay muchas viviendas y los pueblos pijos.
- RentaMedia2021^2. Es lo mismo: cuando aumenta mucho la renta, aumenta la propiedad
- DifPrecioHipotecaProv2. Deja de ser significativa la original. Similar a lo otro.

Los outliers me molestan bastante y me quitan precisión del modelo. Por ejemplo en el caso de municipios con mucha más herencia de lo normal en 2011. Debería quitar outliers?? es que creo que me interesa explicar esos casos.

- PorcentajeTurísticas2021log. el log parece expicar bastante más, pero la original deja de ser significativa. La puedo quitar. Para hacer el log necesito cambiar un municipio con 0% de viviendas turísticas y lo cambio a 0.01%, porque sino no se computa correctamente el logaritmo. Cuando el porcentaje pasa de 0 a un poco, el aumento de propiedad es enorme; cuando pasa de bastante a mucha el aumento es mucho menos notable. En cualquier caso me sale que a más viviendas turísticas más aumento de propiedad.

- DifPrecioHipotecaProv2. Es significativa, la original es casi significativa. Básicamente mismo patrón, cuando aumenta el precio de la hipoteca disminuye probabilidad de propiedad, pero cuando aumenta mucho aumenta.

- ipv2021General2. No lo meto porque se quedan ambas no significativas por poco, si quito la original deja de ser singificativa la elevada a 2.

- Herencia11Munsqrt. Ambas significativas (ya porcentajejoven ha dejado de serlo totalmente). Ahora cuando elevo al cuadrado, cuando aumenta mucho la herencia, la propiedad disminye. pero cuando aumenta si mas, aumenta. He probado raíz cuadrada porque es la forma que toma según el gráfico pero me da menos r cuadrado y es más difícil de interpretar. tengo que ver ejemplos para entender esto mejor.

parece que estoy reduciendo la heterocedasticidad al arreglar las relaciones no lineales. pero aumento muchísimo la multicolinealidad... tengo que repasar eso, o no usar la mismas variables dos vece que digamos, quedarme solo con la que de más info... pero me da rabia porque es que tener ambas me da información.

```{r}
#modelo original
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipv2021General, PorcentajeJovenDif, VaciasDif, SecundariasDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, RentaMedia2021, PorcentajeTurísticas2021, PrecioAlquilerM2, Herencia11Mun) |> 

#transformación

  mutate(PrecioAlquilerM22=PrecioAlquilerM2^2,
         RentaMedia2021_2 = RentaMedia2021^2,
         PorcentajeTurísticas2021log = log(PorcentajeTurísticas2021 +1),
         DifPrecioHipotecaProv2 = DifPrecioHipotecaProv^2,
         Herencia11Mun2 = (Herencia11Mun)^2)|> 
  select(-PorcentajeTurísticas2021)


modelo4b <- lm(PropiedadDifMun ~ ., data = independientes)
summary(modelo4b)

# heterocedasticidad
bptest(modelo4b)

residuos_estandarizados <- rstandard(modelo4b)  
valores_ajustados <- fitted(modelo4b)         
plot(valores_ajustados, residuos_estandarizados,
     xlab = "Valores Ajustados", ylab = "Residuos Estandarizados",
     main = "Gráfico de Residuos Estándar vs. Valores Ajustados")
abline(h = 0, col = "red", lty = 2)  


step_model <- MASS::stepAIC(modelo4b, direction = "both")
summary(step_model)



```

Este modelo es el que he ido construyendo yo. Tnego 0.30 de r cuadrado y es útil porque entiendo cada una de las cosas que he ido metiendo. Me faltaría transofmrar más vairbales (puedo seguir las sugerencias de chat), y con el step model acabo quitando variables que han dejado de ser significativas por el camino. Esto está bien, pero debería analizar qué información pierdo y si me interesa dejarlo así. Por otra parte, normalizo los datos para evitar enorme multicolinealidad, que creo que puedo explicarlo bien igualmente.

### Step model

En resumen, utilizo las transofmraciones que me propone chat a partir de los gráficos de ahí abajo y luego utilizo un step model para quitarme no significativas. Me aumenta que flipas el r cuadrado, no tengo ni multicolinealidad ni heterocedasticidad. Pero debo pensar si me interesan las variables que salen, qué información pierdo, qué cambiar etc. Revisando mis bloques de variables, ver si algún boque se queda huérfano o tal.

Bloques de variables.
- Población
  - PorcentajeJoven
  - PorcentajeEspañola
  - PorcentajeEuropea
  - PorcentajeNoEuropea
  - ParoJuvenil
  - RentaMedia
- Mercado de vivienda
  - PorcentajeVacias
  - PorcentajeSecundarias
  - PorcentajeTurísticas
  - PorcentajeProtegidas
- Precio de vivienda
  - ipv
  - PrecioHipoteca
  - PrecioAlquilerM2
- Régimen de tenencia
  - Herencia11Mun

TODO segun chat

Si no normalizo me da un r cuadrado mucho más bajo y además me da infinita multicolinealidad. He de normalizar, aunque esto me genera problemas con algunas transfomraciones al ser números negativos.

- RentaMedia2021_exp. Me dice que cuando aumenta la renta, disminuye la propiedad, pero esta tendencia conforme más aumenta la renta más se desacelera. Se complementa con la relación cuadrática.
```{r}
# Aplicar transformaciones basadas en observaciones de los gráficos
# Aquí debes elegir las transformaciones basadas en los gráficos generados

municipios <- read_xlsx("municipios.xlsx")
propiedad <- read_xlsx("propiedad.xlsx")

# arregñar datos de reg tenen

municipios <- municipios |> 
    mutate(MUN_LITERAL = ifelse(grepl("\\d", MUN_LITERAL), paste(MUN_LITERAL, PROV_LITERAL), MUN_LITERAL))

todopropiedad <- propiedad |> 
  select(cusec, Propiedad21Mun, Alquiler21Mun, Otro21Mun, Propiedad11Mun, Herencia11Mun, Alquiler11Mun, Otro11Mun, PropiedadDifMun, AlquilerDifMun, OtroDifMun)

municipios <- municipios |> 
  select(-Propiedad21Mun, -Alquiler21Mun, -Otro21Mun, -Compra11Mun, -Herencia11Mun, -Alquiler11Mun, -Otro11Mun, -PropiedadDifMun, -AlquilerDifMun) |> 
  left_join(todopropiedad, by = "cusec") 

municipios <- municipios |> 
  select(-OtroDifMun.x) |> 
  mutate(OtroDifMun = OtroDifMun.y)

municipios <- municipios |> 
  mutate(SecundariasDif=PorcentajeSecundarias2021-PorcentajeSecundarias2011)

numeric_data <- municipios %>%
  ungroup() |> 
  select_if(is.numeric) 

# normalizar
numeric_data <- scale(numeric_data)
numeric_data <- as.data.frame(numeric_data)

#seleccionar variables
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipvGeneralDif, PorcentajeJovenDif, VaciasDif, SecundariasDif, PorcentajeEspañolaDif, PorcentajeEuropeaaDif, PorcentajeNoEuropeaDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, RentaMedia2021, PorcentajeTurísticas2021, PrecioAlquilerM2, Herencia11Mun) |> 

  # Ejemplo de transformaciones:
    mutate(PrecioAlquilerM22=PrecioAlquilerM2^2,
         RentaMedia2021_2 = RentaMedia2021^2,
         PorcentajeTurísleticas2021log = log(PorcentajeTurísticas2021 +1),
         DifPrecioHipotecaProv2 = DifPrecioHipotecaProv^2,
         Herencia11Mun2 = (Herencia11Mun)^2,
           VaciasDif2 = VaciasDif^2,
           RentaMedia2021_exp = exp(RentaMedia2021),
         PorcentajeEspañolaDif2 = PorcentajeEspañolaDif^2,
        PorcentajeEuropeaDif2 = PorcentajeEuropeaaDif^2,
         PorcentajeNoEuropeaDif2 = PorcentajeNoEuropeaDif^2,
    SecundariasDif2 = (SecundariasDif)^2)


# Ajustar el modelo inicial con todas las variables (transformadas y originales)
modelo_inicial <- lm(PropiedadDifMun ~ ., data = independientes)

summary(modelo_inicial)

# Usar stepAIC para seleccionar el mejor modelo
modelo_final <- MASS::stepAIC(modelo_inicial, direction = "both")

# Resumen del modelo final
summary(modelo_final)


bptest(modelo_final)

residuos_estandarizados <- rstandard(modelo_final)  
valores_ajustados <- fitted(modelo_final)         
plot(valores_ajustados, residuos_estandarizados,
     xlab = "Valores Ajustados", ylab = "Residuos Estandarizados",
     main = "Gráfico de Residuos Estándar vs. Valores Ajustados")
abline(h = 0, col = "red", lty = 2)  

vif(modelo_final)

```
El siguiente paso es literalmente ver qué info 'pierdo' en este modelo y cambiar algunas variabesl q me interesen más que otras. Comprobando que no tengo mucha heterocedasticidad ni multicolinealidad

Bloques de variables.
- Población
  - PorcentajeJoven 
  - PorcentajeEspañola. Está elevada a 2.
  - PorcentajeEuropea. Elevada a 2.
  - PorcentajeNoEuropea. X
  - ParoJuvenil. 
  - RentaMedia. Está elevada a 2.
- Mercado de vivienda
  - PorcentajeVacias. 
  - PorcentajeSecundarias.
  - PorcentajeTurísticas.
  - PorcentajeProtegidas. 
- Precio de vivienda
  - ipv X
  - PrecioHipoteca. Original y elevada a 2.
  - PrecioAlquilerM2. Original y elevado a 2.
- Régimen de tenencia.
  - Herencia11Mun. Ambos.

Mi criterio es "lo que decida el step model", par no meter transformadas y originales y meter na transformada similar a la original?

Puedo perder un poco de explicación por consistencia, pero hay que tener en cuenta que cambiar una cosa me cambia todo el modelo. Arreglar:

- Las de nacionalidad que salen explicadas trasnformadas y no
- Las de PrecioAlquilerM2 y Herencia11Mun porque salen ambas. 

Parece que las trasnformadas son mucho más explciativas. No quito las de nacionaidad porquesimplemente algunas tienen relacion lineal y otras cuadrática.

He de meter cesión 2011 por ejemplo?


### Voy a quitar las que no me molan y repetir

Tengo heterocedasticidad pero no parece muy exagerada o con patrones claros, por lo que no me preocupo demasiado. Por otra parte no hay multicolineadlidad a pesar de meter las variables repetidas.


(Intercept). -0.266212. El intercepto indica el valor promedio de PropiedadDifMun cuando todas las variables independientes son cero.

- PorcentajeJovenDif. 0.076670. Un aumento en el porcentaje de jóvenes se asocia con un aumento del 0.076670 en PropiedadDifMun.

- VaciasDif. 0.128515. Un aumento en el porcentaje de viviendas vacías se asocia con un aumento del 0.128515 en PropiedadDifMun.

- SecundariasDif. 0.112695. Un aumento en el porcentaje de viviendas secundarias se asocia con un aumento del 0.112695 en PropiedadDifMun.

- PorcentajeNoEuropeaDif. -0.314526. Un aumento en el porcentaje de residentes no europeos se asocia con una disminución del 0.314526 en PropiedadDifMun.

- DifPrecioHipotecaProv. -0.104423. Un aumento en la diferencia del precio de la hipoteca provincial se asocia con una disminución del 0.104423 en 
PropiedadDifMun.

- ParoJuvenilDif. -0.119523. Un aumento en la tasa de paro juvenil se asocia con una disminución del 0.119523 en PropiedadDifMun.

- ProtegidaDif. -0.132621. Un aumento en el porcentaje de viviendas protegidas se asocia con una disminución del 0.132621 en PropiedadDifMun.

- PorcentajeTurísticas2021. 0.116006. Un mayor porcentaje de viviendas turísticas en 2021 se asocia con un aumento del 0.116006 en PropiedadDifMun.

- PrecioAlquilerM2. -0.227560. Un aumento en el precio del alquiler por metro cuadrado se asocia con una disminución del 0.227560 en PropiedadDifMun.

- Herencia11Mun. 0.168881. Un mayor porcentaje de viviendas heredadas se asocia con un aumento del 0.168881 en PropiedadDifMun.

- PrecioAlquilerM22. 0.112387. La relación cuadrática del precio del alquiler muestra que, aunque los precios más altos inicialmente disminuyen la propiedad, después de cierto punto, aumentos adicionales en los precios pueden estar asociados con un aumento en la propiedad entre jóvenes.

- RentaMedia2021_2. 0.022604. La relación cuadrática de la renta media sugiere que a medida que la renta media aumenta, también lo hace PropiedadDifMun.

- DifPrecioHipotecaProv2. 0.071356. La relación cuadrática del precio de la hipoteca muestra que, después de cierto punto, aumentos adicionales en el precio de la hipoteca están asociados con un aumento en la propiedad entre jóvenes.

- Herencia11Mun2. -0.058298. La relación cuadrática de las herencias muestra una disminución en la propiedad entre jóvenes después de un cierto umbral de viviendas heredadas.

- PorcentajeEspañolaDif2. 0.147920. La relación cuadrática del porcentaje de población española sugiere que aumentos adicionales en este porcentaje están asociados con un aumento en la propiedad entre jóvenes.

- PorcentajeEuropeaDif2. -0.029301. La relación cuadrática del porcentaje de población europea sugiere que aumentos adicionales en este porcentaje están asociados con una disminución en la propiedad entre jóvenes.

```{r}

municipios <- read_xlsx("municipios.xlsx")
propiedad <- read_xlsx("propiedad.xlsx")

# arregñar datos de reg tenen

municipios <- municipios |> 
    mutate(MUN_LITERAL = ifelse(grepl("\\d", MUN_LITERAL), paste(MUN_LITERAL, PROV_LITERAL), MUN_LITERAL))

todopropiedad <- propiedad |> 
  select(cusec, Propiedad21Mun, Alquiler21Mun, Otro21Mun, Propiedad11Mun, Herencia11Mun, Alquiler11Mun, Otro11Mun, PropiedadDifMun, AlquilerDifMun, OtroDifMun)

municipios <- municipios |> 
  select(-Propiedad21Mun, -Alquiler21Mun, -Otro21Mun, -Compra11Mun, -Herencia11Mun, -Alquiler11Mun, -Otro11Mun, -PropiedadDifMun, -AlquilerDifMun) |> 
  left_join(todopropiedad, by = "cusec") 

municipios <- municipios |> 
  select(-OtroDifMun.x) |> 
  mutate(OtroDifMun = OtroDifMun.y)

municipios <- municipios |> 
  mutate(SecundariasDif=PorcentajeSecundarias2021-PorcentajeSecundarias2011)

numeric_data <- municipios %>%
  ungroup() |> 
  select_if(is.numeric) 

# normalizar
numeric_data <- scale(numeric_data)
numeric_data <- as.data.frame(numeric_data)

#seleccionar variables
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipvGeneralDif, PorcentajeJovenDif, VaciasDif, SecundariasDif, PorcentajeEspañolaDif, PorcentajeEuropeaaDif, PorcentajeNoEuropeaDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, RentaMedia2021, PorcentajeTurísticas2021, PrecioAlquilerM2, Herencia11Mun) |> 

  # Ejemplo de transformaciones:
    mutate(PrecioAlquilerM22=PrecioAlquilerM2^2,
         RentaMedia2021_2 = RentaMedia2021^2,
         PorcentajeTurísleticas2021log = log(PorcentajeTurísticas2021 +1),
         DifPrecioHipotecaProv2 = DifPrecioHipotecaProv^2,
         Herencia11Mun2 = (Herencia11Mun)^2,
           VaciasDif2 = VaciasDif^2,
           RentaMedia2021_exp = exp(RentaMedia2021),
         PorcentajeEspañolaDif2 = PorcentajeEspañolaDif^2,
        PorcentajeEuropeaDif2 = PorcentajeEuropeaaDif^2,
         PorcentajeNoEuropeaDif2 = PorcentajeNoEuropeaDif^2,
    SecundariasDif2 = (SecundariasDif)^2)


# Ajustar el modelo inicial con todas las variables (transformadas y originales)

independientes <- independientes %>% 
  select(-PorcentajeTurísleticas2021log)

modelo_inicial <- lm(PropiedadDifMun ~ ., data = independientes)

summary(modelo_inicial)

# Usar stepAIC para seleccionar el mejor modelo
modelo_final <- MASS::stepAIC(modelo_inicial, direction = "both")

# Resumen del modelo final
summary(modelo_final)


bptest(modelo_final)

residuos_estandarizados <- rstandard(modelo_final)  
valores_ajustados <- fitted(modelo_final)         
plot(valores_ajustados, residuos_estandarizados,
     xlab = "Valores Ajustados", ylab = "Residuos Estandarizados",
     main = "Gráfico de Residuos Estándar vs. Valores Ajustados")
abline(h = 0, col = "red", lty = 2)  

vif(modelo_final)

```

Ver mi modelo

```{r}
library(stargazer)
stargazer(modelo_final, type = "text")

stargazer(modelo_final, type = "html", out = "modelo_final.html")




```

### Dando consistencia

Bloques de variables.
- Población
  - PorcentajeJoven 
  - PorcentajeEspañola. Está elevada a 2.
  - PorcentajeEuropea. X
  - PorcentajeNoEuropea.
  - ParoJuvenil. 
  - RentaMedia. Me quedo elevado a 2.
- Mercado de vivienda
  - PorcentajeVacias 
  - PorcentajeSecundarias 
  - PorcentajeTurísticas 
  - PorcentajeProtegidas 
- Precio de vivienda
  - ipv X
  - PrecioHipoteca. Origial y elevada a 2. 
  - PrecioAlquilerM2. Original y elevada a 2.
- Régimen de tenencia.
  - Herencia11Mun. Elevada a 2 y original.

```{r}
independientes <- numeric_data |> 
  select(PropiedadDifMun, ipvGeneralDif, PorcentajeJovenDif, VaciasDif, SecundariasDif, PorcentajeEspañolaDif, PorcentajeEuropeaaDif, PorcentajeNoEuropeaDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, RentaMedia2021, PorcentajeTurísticas2021, PrecioAlquilerM2, Herencia11Mun) |> 

  # Ejemplo de transformaciones:
    mutate(PrecioAlquilerM22=PrecioAlquilerM2^2,
         RentaMedia2021_2 = RentaMedia2021^2,
         PorcentajeTurísleticas2021log = log(PorcentajeTurísticas2021 +1),
         DifPrecioHipotecaProv2 = DifPrecioHipotecaProv^2,
         Herencia11Mun2 = (Herencia11Mun)^2,
           VaciasDif2 = VaciasDif^2,
           RentaMedia2021_exp = exp(RentaMedia2021),
         PorcentajeEspañolaDif2 = PorcentajeEspañolaDif^2,
        PorcentajeEuropeaDif2 = PorcentajeEuropeaaDif^2,
         PorcentajeNoEuropeaDif2 = PorcentajeNoEuropeaDif^2,
    SecundariasDif2 = (SecundariasDif)^2)


independientes <- independientes %>% 
  select(-PrecioAlquilerM2, -Herencia11Mun, -RentaMedia2021_exp)

#sin quitar repetidas
independientes <- independientes %>% 
  select(-RentaMedia2021_exp, -PorcentajeTurísleticas2021log)

# Ajustar el modelo inicial con todas las variables (transformadasRentaMedia2021# Ajustar el modelo inicial con todas las variables (transformadas y originales)
modelo_inicial <- lm(PropiedadDifMun ~ ., data = independientes)

summary(modelo_inicial)

# Usar stepAIC para seleccionar el mejor modelo
modelo_final <- MASS::stepAIC(modelo_inicial, direction = "both")

# Resumen del modelo final
summary(modelo_final)


bptest(modelo_final)

residuos_estandarizados <- rstandard(modelo_final)  
valores_ajustados <- fitted(modelo_final)         
plot(valores_ajustados, residuos_estandarizados,
     xlab = "Valores Ajustados", ylab = "Residuos Estandarizados",
     main = "Gráfico de Residuos Estándar vs. Valores Ajustados")
abline(h = 0, col = "red", lty = 2)  

vif(modelo_final)
```



### Gráficos chat
```{r, fig.height=6, fig.width=12}
# Cargar las librerías necesarias
library(ggplot2)
library(dplyr)
library(MASS)

# Obtener los nombres de las variables independientes (todas excepto la dependiente)
variables_independientes <- setdiff(names(independientes), "PropiedadDifMun")

# Función para generar gráficos y evaluar transformaciones
generar_grafico <- function(variable) {
  # Crear transformaciones
  independientes[[paste0(variable, "2")]] <- independientes[[variable]]^2
  independientes[[paste0(variable, "_sqrt")]] <- sqrt(independientes[[variable]])
  independientes[[paste0(variable, "_log")]] <- log(independientes[[variable]] + 1)  # +1 para evitar log(0)
  
  # Modelos lineales
  modelo_original <- lm(PropiedadDifMun ~ ., data = independientes[, c("PropiedadDifMun", variable)])
  modelo_cuadrado <- lm(PropiedadDifMun ~ ., data = independientes[, c("PropiedadDifMun", variable, paste0(variable, "2"))])
  modelo_sqrt <- lm(PropiedadDifMun ~ ., data = independientes[, c("PropiedadDifMun", variable, paste0(variable, "_sqrt"))])
  modelo_log <- lm(PropiedadDifMun ~ ., data = independientes[, c("PropiedadDifMun", variable, paste0(variable, "_log"))])

  # Generar rango de valores
  rango_variable <- seq(min(independientes[[variable]], na.rm = TRUE), max(independientes[[variable]], na.rm = TRUE), length.out = 100)
  newdata <- data.frame(variable = rango_variable)
  colnames(newdata) <- variable
  newdata[[paste0(variable, "2")]] <- rango_variable^2
  newdata[[paste0(variable, "_sqrt")]] <- sqrt(rango_variable)
  newdata[[paste0(variable, "_log")]] <- log(rango_variable + 1)
  
  # Predicciones
  pred_original <- predict(modelo_original, newdata = newdata)
  pred_cuadrado <- predict(modelo_cuadrado, newdata = newdata)
  pred_sqrt <- predict(modelo_sqrt, newdata = newdata)
  pred_log <- predict(modelo_log, newdata = newdata)

  # Graficar
  plot(independientes[[variable]], independientes$PropiedadDifMun, 
       xlab = variable, ylab = "PropiedadDifMun", main = paste("Relación entre", variable, "y PropiedadDifMun"),
       col = "blue", pch = 16)
  lines(rango_variable, pred_original, col = "red", lwd = 2)
  lines(rango_variable, pred_cuadrado, col = "green", lwd = 2, lty = 2)
  lines(rango_variable, pred_sqrt, col = "purple", lwd = 2, lty = 3)
  lines(rango_variable, pred_log, col = "orange", lwd = 2, lty = 4)
  legend("topright", legend = c("Datos", "Original", "Cuadrado", "Raíz Cuadrada", "Logaritmo"),
         col = c("blue", "red", "green", "purple", "orange"), pch = c(16, NA, NA, NA, NA), 
         lwd = c(NA, 2, 2, 2, 2), lty = c(NA, 1, 2, 3, 4))
}

# Generar gráficos para cada variable independiente
for (variable in variables_independientes) {
  generar_grafico(variable)
}

```



ver distribucion variables
```{r}

# Selecciona las variables independientes
variables_independientes <- c("ipv2021General", "PorcentajeJovenDif", "VaciasDif", "SecundariasDif",
                              "DifPrecioHipotecaProv", "ParoJuvenilDif", "ProtegidaDif", "RentaMedia2021",
                              "PorcentajeTurísticas2021", "PrecioAlquilerM2", "Herencia11Mun")

# Configura la disposición de los gráficos
par(mfrow = c(4, 3))  # Divide el área de trazado en una matriz de 4x3

# Crea histogramas para cada variable
for (variable in variables_independientes) {
  hist(independientes[[variable]], main = paste("Histograma de", variable),
       xlab = variable, col = "skyblue", border = "white")
}



```

relacion entre dependientes e independientes

```{r}
generar_grafico <- function(variable) {
  # Calcula la versión al cuadrado de la variable
  independientes[[paste0(variable, "2")]] <- independientes[[variable]]^2

  # Ajusta un modelo lineal con ambas variables
  modelo <- lm(PropiedadDifMun ~ ., data = independientes[, c("PropiedadDifMun", variable, paste0(variable, "2"))])

  # Genera un rango de valores para la variable
  rango_variable <- seq(min(independientes[[variable]]), max(independientes[[variable]]), length.out = 100)

  # Calcula las predicciones del modelo para el rango de valores
  newdata <- independientes[1:100, ]  # Crea un nuevo data.frame con las primeras 100 filas de 'independientes'
  newdata[[variable]] <- rango_variable  # Reemplaza la columna de la variable con 'rango_variable'
  newdata[[paste0(variable, "2")]] <- rango_variable^2  # Añade la columna de la variable al cuadrado
  predicciones <- predict(modelo, newdata = newdata)

  # Grafica los datos de dispersión y la línea de la relación
  plot(independientes[[variable]], independientes$PropiedadDifMun, 
       xlab = variable, ylab = "PropiedadDifMun", main = paste("Relación entre", variable, "y Propiedad"),
       col = "blue", pch = 16)
  lines(rango_variable, predicciones, col = "red", lwd = 2)
  legend("topright", legend = c("Datos", "Línea de Regresión"), col = c("blue", "red"), pch = c(16, NA), lwd = c(NA, 2))
}

# Ahora puedes llamar a la función para cada variable en tu lista
variables_independientes <- c("ipv2021General", "PorcentajeJovenDif", "VaciasDif", "SecundariasDif",
                              "DifPrecioHipotecaProv", "ParoJuvenilDif", "ProtegidaDif", "RentaMedia2021",
                              "PorcentajeTurísticas2021", "PrecioAlquilerM2", "Herencia11Mun")

for (variable in variables_independientes) {
  generar_grafico(variable)
}


```
He de meter alquiler11mun? por queno? aclarar los regimenes de tenencia.

Probar a ver estas relaciones antes de quedarme solo con las significativas

F-Test. Es mejor el modelo nuevo.
```{r}
# Comparar los dos modelos con un F-test
anova_comparison <- anova(modelo4, modelo_final)
print(anova_comparison)

```





### Logit

Si no equilibro las clases, un 96% es descenso y 32% aumento de propiedad. La accuracy es de 85%, lo cual es lógico porque las clases están desbalanceadas. Vemos que la especificidad es de 96%, es decir, predice con mucho acierto los descensos, pero la sensibilidad es de sólo 0.32, detecta mal los aumentos.

Si se equilibran las clases con N=1000 la precisión baja a 72%, especificidad a 71% pero la sensibilidad aumenta al 73%.

```{r}

# Preparar datos
municipios <- read_xlsx("municipios.xlsx")
propiedad <- read_xlsx("propiedad.xlsx")

municipios <- municipios |> 
    mutate(MUN_LITERAL = ifelse(grepl("\\d", MUN_LITERAL), paste(MUN_LITERAL, PROV_LITERAL), MUN_LITERAL))

numeric_data <- municipios %>%
  ungroup() |> 
  select_if(is.numeric) 

numeric_data <- numeric_data %>%
  mutate(Propiedad = ifelse(PropiedadDifMun >= 0, 1, 0)) %>%
  select(Propiedad, RentaMedia2021, PorcentajeJoven2021, PorcentajeJovenDif, PorcentajeVacias2021, PorcentajeSecundarias2021, PorcentajeEspañola, PorcentajeProtegidas2021, ProtegidaDif, PrecioAlquilerM2) 

# Equilibrar clases
prop.table(table(numeric_data$Propiedad)) 

library(ROSE)
numeric_data <- ovun.sample(Propiedad~., 
                    data = numeric_data, 
                    method = "over", 
                    N = 1000)$data

table(numeric_data$Propiedad)
# Modelo
modelo <- glm(Propiedad ~ ., data = numeric_data, family = binomial(link = "logit"))

summary(modelo)

# Matriz de confusión
prob_pred <- predict(modelo, type = "response")
clases_pred <- ifelse(prob_pred > 0.5, 1, 0)

confusion_matrix <-table(Real = numeric_data$Propiedad, Predicho = clases_pred)
confusion_matrix

# Accuracy
sum(diag(confusion_matrix)) / sum(confusion_matrix)

# Sensibilidad
confusion_matrix[2, 2] / sum(confusion_matrix[2, ])

# Especificidad
confusion_matrix[1, 1] / sum(confusion_matrix[1, ])

```


## Apuntes

Parte del descriptivo de los individuos lo tengo ya hecho

Preparar clusters etc copiandome del trabajo de advanced modelling. También tengo ahí texto que describe la pregunta de investigación, los análisis...

- ¿Tipos de perfil de individuo comprante?

Hacer cluster con solo regimenes de enencia de munis? ver diferencias entre si pierde otro, si pierde alquiler... como he analizao un poco.


# Pca con nuevo modelo

Sorprendentemente? Quedándome solo con las variables del step model, en vez de todas las originales y transformadas, explico más variabilidad. Además, para interpretar es más fácil, y es más consistente utilizar las mismas que el modelo. Así que elijo usar sólo las que incluyo en mi modelo_final. Con menos componentes explico menos que mi PCA original, pero con 10 explico un poco más. 

Quizá no tiene sentido meter las trasnformadas aquí, y sí tiene sentido meter los regímenes de tenencia.

```{r}

# Nomre de municipios
names = municipios$MUN_LITERAL
prov = municipios$PROV_LITERAL
ccaa = municipios$CCAA

# Selección de variables del Step Model
selected_vars <- numeric_data %>% 
  select(PropiedadDifMun, AlquilerDifMun, OtroDifMun, Herencia11Mun, PorcentajeJovenDif, VaciasDif, SecundariasDif, PorcentajeNoEuropeaDif, DifPrecioHipotecaProv, ParoJuvenilDif, ProtegidaDif, PorcentajeTurísticas2021, PrecioAlquilerM2)

# Creating the components
# Tengo que poner scale aunque ya las haya normalizado porque sino me da algo raro
set.seed(123)
pca = prcomp(selected_vars, scale=T)
summary(pca)

# Plot of the variability explained by components
fviz_screeplot(pca, addlabels = TRUE)



```
Analizar componente 1

*Componente 1*. Las variables que más contribuyen a este componente es PrecioAlquilerM2, SecundariasDif, AlquilerDifMun, PropiedadDifMun, VaciasDif y Herencia11Mun. Son variables relacionadas con el precio de la vivienda de los municipios, también con el mercado de la vivienda. No tiene relación cosas como las características de la población juvenil.

- PrecioAlquilerM2. Muy bajo el precio del alquiler.
- SecundariasDif. Gran aumento de viviendas secundarias.
- AlquilerDifMun. Gran descenso del alquiler.
- PropiedadDifMun. Bastante aumento de la propiedad.
- VaciasDif. Bastante aumento de viviendas vacías.
- Herencia11Mun. Bastante herencia de viviendas principales en los municipios en 2011.

Los municipios con más puntuación en este componente son municipios muy pequeños de Ourense y Lugo. Son municipios rurales con pocas con gran cantidad de viviendas secundarias o vacías, bajo precio de alquiler... También vemos que tienen más herencia que otros municipios, gran reducción del alquiler y aumento de la propiedad.

Por otra parte, los municipios con menor puntuación son municipios con pocas viviendas secundarias, un alquiler caro, o además con muy poco aumento de viviendas vacías. También han experimentado un aumento del alquiler significativo.

Algo así como ganancia de rpopiedad relacionada con caracteristicas de mmercado de la vivienda, secundarias.


```{r}
# Contribution of variables to component 1
fviz_contrib(pca, choice = "var", axes = 1)

# Plot adjustments
n <- 10
col_pos <- colorRampPalette(c("#CCE6CC", "#208909"))(n)
col_neg <- colorRampPalette(c("#FFE6E6", "#B30000"))(n)
coefs <- pca$rotation[,1]
valor_max <- max(coefs)
valor_min <- min(coefs)
coefs_ajustados <- coefs - valor_min + 1
colores <- ifelse(coefs >= 0, col_pos[ceiling((coefs_ajustados / (valor_max - valor_min + 1)) * n)], 
                  col_neg[ceiling((abs(coefs_ajustados) / (valor_max - valor_min + 1)) * n)])

# Plot
barplot(coefs, las = 2, col = colores, cex.names = 0.8)

#Ranking of municipalities of this component
names[order(pca$x[,1], decreasing=T)][1:5]
names[order(pca$x[,1])][1:5]

```

Analizar componente 2

*Componente 2*. Las variables que más contribuyen a este componente es ParoJuvenilDif, ProtegidaDif, PorcentajeTurísticas2021, PrecioAlquilerM2, VaciasDif y PorcentajeNoEuropeaDif. Esta vez son variables más relacionadas con las características de la población, así como el mercado de vivienda.

- ParoJuvenilDif. Ha aumentado muchísimo el paro juvenil. 
- ProtegidaDif. Ha disminuido muchísimo la cantidad de viviendas protegidas.
- PorcentajeTurísticas2021. Muchas viviendas turísticas.
- PrecioAlquilerM2. Alquiler bastante caro.
- VaciasDif. Bastante aumento de viviendas vacías.
- PorcentajeNoEuropeaDif. Ha disminuido mucho la cantidad de personas no europeas.
- PropiedadDifMun. Ha aumentado la propiedad.
- AlquilerDifMun. Ha disminuido en igual manera el alquiler.

Los municipios con más puntuación en este componente son Ceuta, La Oliva, Adeje... Son municipios con un aumento en propiedad menos pronunciado que en el componente 1 (o una reducción muy  limitada). Parece ser viviendas donde el mercado de la vivienda es menos favorable para la propiedad por menos viviendas protegidas, pero también hay más vacías. Un aumento de viviendas turísticas que puede relacionarse con el mayor precio del alquiler y parece que con menos población no europea.

Por otra parte, los municipios con menor puntuación son Torre-Pacheco, Mazazrrón, Lorca. Estos municipios parecen estar en una situación más estable en términos de empleo juvenil y mercado inmobiliario. Menos presión turística y alquileres más asequibles sugieren un mercado menos competitivo y más accesible. La diversidad demográfica puede estar aumentando, lo que podría ser un reflejo de una mayor integración de inmigrantes no europeos. La tendencia hacia la propiedad de viviendas podría indicar una preferencia por la estabilidad y permanencia.

Algo así como ganancia de rpopiedad relacionada con caracteristicas de paro, nacionalidad

```{r}

# Contribution of variables to component 1
fviz_contrib(pca, choice = "var", axes = 2)

# Plot adjustments
n <- 10
col_pos <- colorRampPalette(c("#CCE6CC", "#208909"))(n)
col_neg <- colorRampPalette(c("#FFE6E6", "#B30000"))(n)
coefs <- pca$rotation[,2]
valor_max <- max(coefs)
valor_min <- min(coefs)
coefs_ajustados <- coefs - valor_min + 1
colores <- ifelse(coefs >= 0, col_pos[ceiling((coefs_ajustados / (valor_max - valor_min + 1)) * n)], 
                  col_neg[ceiling((abs(coefs_ajustados) / (valor_max - valor_min + 1)) * n)])

# Plot
barplot(coefs, las = 2, col = colores, cex.names = 0.8)

#Ranking of municipalities of this component
names[order(pca$x[,2], decreasing=T)][1:5]
names[order(pca$x[,2])][1:5]

```

Plot de componentes 

```{r}
p <-data.frame(z1 = pca$x[,1], z2 = pca$x[,2]) %>%
  ggplot(aes(z1, z2, label = names, color = ccaa)) +
  geom_point(size = 0) +
  labs(title = "First two principal components (scores)", x = "PC1", y = "PC2") +  theme_bw() +   theme(legend.position = "bottom") +
  geom_text(size = 3, hjust = 0.6, vjust = 0, check_overlap = T)

p

# Versión interactiva
ggplotly(p)
```

Cuantos clusters usar?

Dos métodos sugieren 2, el tercero sugiere 5.
```{r}
fviz_nbclust(scale(selected_vars), kmeans, method = 'wss', k.max = 20, nstart = 1000)

fviz_nbclust(scale(selected_vars), kmeans, method = 'silhouette', k.max = 20, nstart = 1000)

fviz_nbclust(scale(selected_vars), kmeans, method = 'gap_stat', k.max = 10, nstart = 100, nboot = 100)

```


Que es cada cluster?

```{r, fig.height=6, fig.width=12}


fit <- kmeans(selected_vars, centers = 3, nstart = 100)
fit

selected_vars$cluster <- fit$cluster

centers=fit$centers

barplot(centers[1,], las=2, col="#097969")
barplot(centers[2,], las=2, col="#097969")

fviz_cluster(fit, data = selected_vars, geom = c("point"), ellipse.type = 'norm', pointsize = 1, show.clust.cent = FALSE) +
  theme_minimal() + geom_text(label = names, hjust = 0, vjust = 0, size = 2, check_overlap = TRUE) +
  scale_fill_brewer(palette = "Paired", guide = FALSE)


```

